# 그래프
- 정점 (node, vertex) 과 간선(edge) 으로 이루어진 자료구조

## 차수
- 차수란 각 정점에서 다른 정점으로 연결된 간선의 수
  - 유향 그래프의 경우 in degree, out degree 진입, 진출 차수
  - 무향 그래프의 경우 degree 차수

## 종류
- 유향 / 무향 그래프: 그래프 정점 간 방향성 존재 유무
- 순환 / 비순환 그래프 : 그래프 정점 간 사이이클 존재 유무
- 완전 그래프 : 모든 정점의 쌍에 대해 간선이 연결된 그래프
- 연결 그래프 : 임의의 두 정점 사이의 경로가 존재하는 그래프
- 단순 그래프 : 루프 없이 두 정점 사이의 간선이 1개 이하인 그래프

## 그래프 주의점
- 정확한 조건이 정의된 그래프가 아니라면 그래프 형식을 간과하지 말자.
  - 정점간 연결 없이 두개의 그래프가 있는 그래프
  - 자기가 자기를 스스로 참조하는 그래프
  - 정점간의 간선이 1개 이상인 그래프

## 그래프 표현하기
- 인접 행렬
  - 인접한 행렬로 그래프를 나타냄
  - 예를들어 행은 출발 정점, 열은 도착 정점으로 (1,2) 가 1 인 경우 1 -> 2 로 갈 수 있음
    - 유향 그래프의 경우 (1,2) 와 (2,1) 은 다르며, 무향 그래프의 경우 입력시 (1,2) 와 (2,1) 에 모두 마킹이 필요하단 점을 기억하자.
  - 연결 확인 o(1), 공간 복잡도 o(V^2), a와 연결된 정점 확인 o(v) 
  - 두 정점의 연결 여부를 자주 확인하는 경우, e 의 갯수가 이미 v^2 에 가까운 경우 상대적으로 효율적
- 인접 리스트
  - 인접 행렬과 비교해 정점이 많고 간선이 상대적으로 적은 상황에서 공간 절약
  - 연결 확인 o(min(deg(a), deg(b))), 공간 복잡도 o(v + e),  a와 연결된 정점 확인 o(deg(a)) 
  - 특정 정점에 연결된 모든 정점 확인하는 경우, e 의 갯수가 v^2 에 못미치는 경우 상대적으로 효율적


## bfs
- 그래프의 bfs 는 배열의 bfs 과 풀이법과 문제 유형등이 비슷하다. 근데 이제 그래프를 곁들인.
  - 인접한 인덱스로의 이동이 아닌 v 와 연결된 정점에 대한 탐색만 진행하면 된다.
  - visited 배열을 활용하여 방문 여부를 확인, dist 배열로 이동거리를 확인 등 기본 구조가 비슷하다.
  - 시간 복잡도는 o(v + e) 로 1000 번의 bfs 를 수행하는 경우 o(1000(v + e)) 가 된다.
    - 무향 그래프인 경우 2e, 유향 그래프인 경우 e 로 모든 정점에 대해 간선만큼 확인을 하기 때문에 e 가 된다.

## dfs
- dfs 를 보면 순회 방식과 재귀 방식의 차이가 있다.
- 재귀 방식은 `방문 여부`를 `실제 요소에 방문할 때` 마킹한다.
- 순회 방식의 경우 스택에 요소를 적재하면서 `방문 여부`를 `스택에 적재할 때` 마킹한다.
  - 순회 방식을 관념적인 dfs 의 방문 순서에 맞춰서 구현하기 위해서는 visited 확인 및 마킹 표시를 stack 에서 요소를 꺼낸 직후
  - 즉 실제 요소에 방문할 때 진행하면 방문 순서가 재귀와 같아질 수 있다.

